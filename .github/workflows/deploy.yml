name: Deploy
on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to deploy (e.g., v1.2.3). Must have a corresponding release artifact from a previous successful 'Build & Package on Tag' workflow run."
        required: true
        type: string
  workflow_run:
    workflows: ["Build & Package on Tag"]
    types: [completed]

permissions:
  contents: read
  actions: read

concurrency:
  # Serialize per tag when available; otherwise, fall back to the originating run id to avoid cross-tag serialization
  group: deploy-${{ github.event_name == 'workflow_dispatch' && inputs.tag || (github.event_name == 'workflow_run' && (github.event.workflow_run.head_branch || github.event.workflow_run.id)) || github.run_id }}
  cancel-in-progress: false

jobs:
  fetch-bundle:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    outputs:
      bundle_path: ${{ steps.set-path.outputs.path }}
      tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
      - name: Get tag
        id: get-tag
        run: |
          if [ -n "${{ inputs.tag }}" ]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${{ github.event.workflow_run.head_branch }}"
          fi
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
      - name: Download bundle from Build workflow (auto-trigger)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: release-bundle
          path: bundle
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      - name: Download bundle from GitHub Release (manual trigger)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p bundle
          gh release download "${{ steps.get-tag.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            -p "release-${{ steps.get-tag.outputs.tag }}.tar.gz" \
            -p "release-${{ steps.get-tag.outputs.tag }}.sha256" \
            -D bundle
      - name: Verify bundle exists
        run: |
          BUNDLE_PATH="bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz"
          if [ ! -f "$BUNDLE_PATH" ]; then
            echo "::error::Bundle file not found: $BUNDLE_PATH"
            echo "Available files in bundle directory:"
            ls -la bundle/ || echo "bundle directory does not exist"
            exit 1
          fi
      - name: Verify bundle checksum
        run: |
          set -euo pipefail
          cd bundle
          if [ ! -f "release-${{ steps.get-tag.outputs.tag }}.sha256" ]; then
            echo "::error::Checksum file not found: release-${{ steps.get-tag.outputs.tag }}.sha256"
            ls -la
            exit 1
          fi
          # Verify integrity; fails the job on mismatch
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum -c "release-${{ steps.get-tag.outputs.tag }}.sha256"
          else
            shasum -a 256 -c "release-${{ steps.get-tag.outputs.tag }}.sha256"
          fi
      - name: Set bundle path
        id: set-path
        run: echo "path=bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz" >> "$GITHUB_OUTPUT"
      - name: Upload bundle for downstream jobs
        uses: actions/upload-artifact@v4
        with:
          name: current-bundle
          path: |
            bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz
            bundle/release-${{ steps.get-tag.outputs.tag }}.sha256

  deploy-db:
    needs: fetch-bundle
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    outputs:
      new_edition: ${{ steps.create-edition.outputs.edition }}
    steps:
      - uses: actions/checkout@v4
      - name: Download bundle from current workflow
        uses: actions/download-artifact@v4
        with:
          name: current-bundle
          path: bundle
      - uses: gvenzl/setup-oracle-sqlcl@v1
        with:
          version: latest
      - name: Restore ADB wallet
        run: |
          set -euo pipefail
          mkdir -p "$RUNNER_TEMP/wallet"
          printf %s "${{ secrets.ADB_WALLET_BASE64 }}" | base64 -d > "$RUNNER_TEMP/wallet.zip"
          unzip -P "${{ secrets.ADB_WALLET_PASSWORD }}" -q "$RUNNER_TEMP/wallet.zip" -d "$RUNNER_TEMP/wallet"
          echo "TNS_ADMIN=$RUNNER_TEMP/wallet" >> $GITHUB_ENV
      - name: Extract DB artifact
        run: |
          set -euo pipefail
          mkdir -p bundle
          if [ ! -f "${{ needs.fetch-bundle.outputs.bundle_path }}" ]; then
            echo "::error::Bundle file not found at: ${{ needs.fetch-bundle.outputs.bundle_path }}"
            exit 1
          fi
          # Verify checksum before extraction
          SHA_FILE="bundle/$(basename "${{ needs.fetch-bundle.outputs.bundle_path }}" | sed 's/\.tar\.gz$/.sha256/')"
          if [ -f "$SHA_FILE" ]; then
            (cd bundle && sha256sum -c "$(basename "$SHA_FILE")")
          fi
          tar -xzf "${{ needs.fetch-bundle.outputs.bundle_path }}" -C bundle
          DB_ZIP="bundle/db/odbvue-db-${{ needs.fetch-bundle.outputs.tag }}.zip"
          if [ ! -f "$DB_ZIP" ]; then
            echo "::error::Database artifact not found in bundle: $DB_ZIP"
            echo "Contents of bundle:"
            find bundle -type f || true
            exit 1
          fi
          echo "ART=$DB_ZIP" >> $GITHUB_ENV
      - name: Smoke test ADB connection
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<'SQL'
          SELECT 'connected as '||USER whoami FROM dual;
          exit
          SQL
      - name: Create new edition for deployment
        id: create-edition
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
          TAG: ${{ needs.fetch-bundle.outputs.tag }}
        run: |
          set -euo pipefail
          # Convert tag format: v1.2.3 -> v1_2_3 (Liquibase compatible)
          EDITION_TAG=$(echo "$TAG" | tr '.' '_')
          NEW_EDITION="ODBVUE_${EDITION_TAG}"
          
          echo "Creating new edition: $NEW_EDITION"
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<SQL
          BEGIN
            EXECUTE IMMEDIATE 'CREATE EDITION $NEW_EDITION AS CHILD OF ORA\$BASE INVISIBLE';
            DBMS_OUTPUT.PUT_LINE('Edition created: $NEW_EDITION');
          EXCEPTION
            WHEN OTHERS THEN
              IF SQLCODE = -38801 THEN  -- Edition already exists
                DBMS_OUTPUT.PUT_LINE('Edition already exists: $NEW_EDITION');
              ELSE
                RAISE;
              END IF;
          END;
          /
          exit
          SQL
          
          echo "edition=$NEW_EDITION" >> "$GITHUB_OUTPUT"
      - name: Deploy to new edition
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          NEW_EDITION="${{ steps.create-edition.outputs.edition }}"
          
          echo "Deploying to edition: $NEW_EDITION"
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<SQL
          ALTER SESSION SET EDITION_NAME = $NEW_EDITION;
          set sqlclui off
          project deploy -file "$ART"
          exit
          SQL
      - name: Validate new edition
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          NEW_EDITION="${{ steps.create-edition.outputs.edition }}"
          
          echo "Validating new edition: $NEW_EDITION"
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<'SQL'
          ALTER SESSION SET EDITION_NAME = ${NEW_EDITION};
          SELECT USER FROM dual;
          exit
          SQL
      - name: Switch to new edition
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          NEW_EDITION="${{ steps.create-edition.outputs.edition }}"
          
          echo "Activating new edition: $NEW_EDITION"
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<SQL
          ALTER DATABASE DEFAULT EDITION = $NEW_EDITION;
          COMMIT;
          exit
          SQL
      - name: Get deployment history
        id: get-history
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          
          echo "Deployment history (via DATABASECHANGELOG):"
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<'SQL'
          SELECT 
            tag,
            MAX(dateexecuted) AS deployed_at,
            COUNT(*) AS changesets,
            LISTAGG(author, ', ') WITHIN GROUP (ORDER BY author) AS authors
          FROM databasechangelog
          WHERE tag IS NOT NULL
          GROUP BY tag
          ORDER BY dateexecuted DESC;
          exit
          SQL
      - name: Get cleanup targets
        id: get-cleanup
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          
          echo "Finding editions to cleanup (keeping last 3)..."
          EDITIONS_TO_DROP=$(sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<'SQL'
          WITH tag_summary AS (
            SELECT 
              tag,
              ROW_NUMBER() OVER (ORDER BY MAX(dateexecuted) DESC) AS tag_rank,
              MAX(dateexecuted) AS deployed_at
            FROM databasechangelog
            WHERE tag IS NOT NULL
            GROUP BY tag
          )
          SELECT 'ODBVUE_' || tag FROM tag_summary WHERE tag_rank > 3 ORDER BY deployed_at ASC;
          exit
          SQL
          )
          
          if [ -z "$EDITIONS_TO_DROP" ]; then
            echo "No editions to cleanup"
          else
            echo "Editions to drop:"
            echo "$EDITIONS_TO_DROP"
          fi
          
          echo "editions<<EOF" >> "$GITHUB_ENV"
          echo "$EDITIONS_TO_DROP" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
      - name: Cleanup old editions
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          
          if [ -z "$editions" ]; then
            echo "No editions to cleanup"
            exit 0
          fi
          
          echo "$editions" | while read -r edition; do
            if [ -n "$edition" ] && [ "$edition" != "" ]; then
              echo "Dropping edition: $edition"
              sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<SQL
              BEGIN
                EXECUTE IMMEDIATE 'DROP EDITION $edition CASCADE';
                DBMS_OUTPUT.PUT_LINE('Successfully dropped: $edition');
              EXCEPTION
                WHEN OTHERS THEN
                  IF SQLCODE = -38802 THEN  -- Edition doesn't exist
                    DBMS_OUTPUT.PUT_LINE('Edition does not exist: $edition');
                  ELSE
                    RAISE;
                  END IF;
              END;
              /
              exit
              SQL
            fi
          done
          
          echo "Cleanup completed"
      - name: Rollback on failure
        if: failure()
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
        run: |
          set -euo pipefail
          NEW_EDITION="${{ steps.create-edition.outputs.edition }}"
          
          echo "Deployment failed! Rolling back..."
          echo "Dropping failed edition: $NEW_EDITION"
          
          sql "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" <<SQL
          BEGIN
            EXECUTE IMMEDIATE 'DROP EDITION $NEW_EDITION CASCADE';
            DBMS_OUTPUT.PUT_LINE('Rolled back: $NEW_EDITION');
          EXCEPTION
            WHEN OTHERS THEN
              IF SQLCODE != -38802 THEN  -- Edition doesn't exist
                RAISE;
              END IF;
          END;
          /
          exit
          SQL

  deploy-web:
    needs: [fetch-bundle, deploy-db]
    if: ${{ success() && (github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')) }}
    runs-on: ubuntu-latest
    steps:
      - name: Download bundle from current workflow
        uses: actions/download-artifact@v4
        with:
          name: current-bundle
          path: bundle
      - name: Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          printf %s "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          printf %s "${{ secrets.SSH_HOST_KEY }}" >> ~/.ssh/known_hosts
      - name: Extract bundle
        run: |
          set -euo pipefail
          if [ ! -f "${{ needs.fetch-bundle.outputs.bundle_path }}" ]; then
            echo "::error::Bundle file not found at: ${{ needs.fetch-bundle.outputs.bundle_path }}"
            exit 1
          fi
          # Verify checksum before extraction
          SHA_FILE="bundle/$(basename "${{ needs.fetch-bundle.outputs.bundle_path }}" | sed 's/\.tar\.gz$/.sha256/')"
          if [ -f "$SHA_FILE" ]; then
            (cd bundle && sha256sum -c "$(basename "$SHA_FILE")")
          fi
          tar -xzf "${{ needs.fetch-bundle.outputs.bundle_path }}" -C bundle
          echo "Extracted bundle contents:"
          find bundle -type f -o -type d | head -20 || true
      - name: Deploy with blue/green strategy
        run: |
          set -euo pipefail
          
          for site in apps wiki main; do
            # Get current active slot
            ACTIVE=$(ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "readlink /var/www/$site/current 2>/dev/null | grep -oE '(blue|green)' || echo blue")
            INACTIVE=$([ "$ACTIVE" = "blue" ] && echo "green" || echo "blue")
            TARGET_DIR="/var/www/$site/$INACTIVE"
            
            echo "Deploying $site: $ACTIVE -> $INACTIVE"
            
            # Clean and create target directory (owned by deploy user for rsync)
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo rm -rf '$TARGET_DIR' && sudo mkdir -p '$TARGET_DIR' && sudo chown ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} '$TARGET_DIR'"
            
            # Upload content (rsync can now write)
            rsync -az -e "ssh -i ~/.ssh/deploy_key" bundle/$site/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:"$TARGET_DIR/"
            
            # Fix permissions (change to nginx owner)
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo chown -R nginx:nginx '$TARGET_DIR' && sudo find '$TARGET_DIR' -type d -exec chmod 755 {} \; && sudo find '$TARGET_DIR' -type f -exec chmod 644 {} \;"
            
            # Flip symlink atomically
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo ln -sfn '$TARGET_DIR' /var/www/$site/current.tmp && sudo mv -T /var/www/$site/current.tmp /var/www/$site/current"
          done
          
          # Validate and reload nginx
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo nginx -t && sudo systemctl reload nginx"
