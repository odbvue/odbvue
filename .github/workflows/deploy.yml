name: Deploy
on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to deploy (e.g., v1.2.3). Must have a corresponding release artifact from a previous successful 'Build & Package on Tag' workflow run."
        required: true
        type: string
  workflow_run:
    workflows: ["Build & Package on Tag"]
    types: [completed]

permissions:
  contents: read
  actions: read

concurrency:
  # Serialize per tag when available; otherwise, fall back to the originating run id to avoid cross-tag serialization
  group: deploy-${{ github.event_name == 'workflow_dispatch' && inputs.tag || (github.event_name == 'workflow_run' && (github.event.workflow_run.head_branch || github.event.workflow_run.id)) || github.run_id }}
  cancel-in-progress: false

jobs:
  fetch-bundle:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    outputs:
      bundle_path: ${{ steps.set-path.outputs.path }}
      tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
      - name: Get tag
        id: get-tag
        run: |
          if [ -n "${{ inputs.tag }}" ]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${{ github.event.workflow_run.head_branch }}"
          fi
          echo "tag=${TAG}" >> "$GITHUB_OUTPUT"
      - name: Download bundle from Build workflow (auto-trigger)
        if: ${{ github.event_name == 'workflow_run' }}
        uses: actions/download-artifact@v4
        with:
          name: release-bundle
          path: bundle
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.workflow_run.id }}
      - name: Download bundle from GitHub Release (manual trigger)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p bundle
          gh release download "${{ steps.get-tag.outputs.tag }}" \
            --repo "${{ github.repository }}" \
            -p "release-${{ steps.get-tag.outputs.tag }}.tar.gz" \
            -p "release-${{ steps.get-tag.outputs.tag }}.sha256" \
            -D bundle
      - name: Verify bundle exists
        run: |
          BUNDLE_PATH="bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz"
          if [ ! -f "$BUNDLE_PATH" ]; then
            echo "::error::Bundle file not found: $BUNDLE_PATH"
            echo "Available files in bundle directory:"
            ls -la bundle/ || echo "bundle directory does not exist"
            exit 1
          fi
      - name: Verify bundle checksum
        run: |
          set -euo pipefail
          cd bundle
          if [ ! -f "release-${{ steps.get-tag.outputs.tag }}.sha256" ]; then
            echo "::error::Checksum file not found: release-${{ steps.get-tag.outputs.tag }}.sha256"
            ls -la
            exit 1
          fi
          # Verify integrity; fails the job on mismatch
          if command -v sha256sum >/dev/null 2>&1; then
            sha256sum -c "release-${{ steps.get-tag.outputs.tag }}.sha256"
          else
            shasum -a 256 -c "release-${{ steps.get-tag.outputs.tag }}.sha256"
          fi
      - name: Set bundle path
        id: set-path
        run: echo "path=bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz" >> "$GITHUB_OUTPUT"
      - name: Upload bundle for downstream jobs
        uses: actions/upload-artifact@v4
        with:
          name: current-bundle
          path: |
            bundle/release-${{ steps.get-tag.outputs.tag }}.tar.gz
            bundle/release-${{ steps.get-tag.outputs.tag }}.sha256

  deploy-db:
    needs: fetch-bundle
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Download bundle from current workflow
        uses: actions/download-artifact@v4
        with:
          name: current-bundle
          path: bundle
      - uses: gvenzl/setup-oracle-sqlcl@v1
        with:
          version: latest
      - name: Extract bundle and verify database sources
        run: |
          set -euo pipefail
          if [ ! -f "${{ needs.fetch-bundle.outputs.bundle_path }}" ]; then
            echo "::error::Bundle file not found at: ${{ needs.fetch-bundle.outputs.bundle_path }}"
            exit 1
          fi
          # Verify checksum before extraction
          SHA_FILE="bundle/$(basename "${{ needs.fetch-bundle.outputs.bundle_path }}" | sed 's/\.tar\.gz$/.sha256/')"
          if [ -f "$SHA_FILE" ]; then
            (cd bundle && sha256sum -c "$(basename "$SHA_FILE")")
          fi
          tar -xzf "${{ needs.fetch-bundle.outputs.bundle_path }}" -C bundle
          DB_SRC="bundle/db/db-src-${{ needs.fetch-bundle.outputs.tag }}.tar.gz"
          if [ ! -f "$DB_SRC" ]; then
            echo "::error::Database sources not found in bundle: $DB_SRC"
            echo "Contents of bundle:"
            find bundle -type f || true
            exit 1
          fi
          echo "Database sources verified at: $DB_SRC"
      - name: Restore ADB wallet
        run: |
          set -euo pipefail
          WALLET_DIR="/tmp/wallet"
          mkdir -p "$WALLET_DIR"
          printf %s "${{ secrets.ADB_WALLET_BASE64 }}" | base64 -d > "$WALLET_DIR/wallet.zip"
          unzip -P "${{ secrets.ADB_WALLET_PASSWORD }}" -q -o "$WALLET_DIR/wallet.zip" -d "$WALLET_DIR"
          echo "TNS_ADMIN=$WALLET_DIR" >> $GITHUB_ENV
          echo "Wallet extracted to $WALLET_DIR"
      - name: Deploy DB
        env:
          ADB_USER: ${{ secrets.ADB_USER }}
          ADB_PASSWORD: ${{ secrets.ADB_PASSWORD }}
          ADB_TNS_ALIAS: ${{ secrets.ADB_TNS_ALIAS }}
          ADB_SCHEMA_NAME: ${{ secrets.ADB_SCHEMA_NAME }}
          ADB_SCHEMA_PASSWORD: ${{ secrets.ADB_SCHEMA_PASSWORD }}
        run: |
          set -euo pipefail
          VERSION="${{ needs.fetch-bundle.outputs.tag }}"
          NAME="odbvue-db"
          
          # Calculate EDITION from schema name and version
          EDITION="${ADB_SCHEMA_NAME}_$(echo "$VERSION" | tr . _)"
          EDITION="${EDITION^^}"
          
          # Extract db sources from bundle
          DB_BUNDLE="bundle/db/db-src-${VERSION}.tar.gz"
          if [ ! -f "$DB_BUNDLE" ]; then
            echo "::error::Database sources not found in bundle: $DB_BUNDLE"
            echo "Available files in bundle:"
            find bundle -type f || true
            exit 1
          fi
          
          # Create a temporary directory for db sources
          TEMP_DB_DIR=$(mktemp -d)
          tar -xzf "$DB_BUNDLE" -C "$TEMP_DB_DIR"
          
          echo "Deploying version: $VERSION"
          echo "Connecting to ${ADB_TNS_ALIAS}..."
          
          # Generate artifact from source AND deploy in one connected session
          # This ensures schema/edition initialization runs
          # Must run from temp_db_dir where .dbtools exists
          cd "$TEMP_DB_DIR"
          
          sql -nohistory "${ADB_USER}/${ADB_PASSWORD}@${ADB_TNS_ALIAS}" << ENDSQL
          prompt Connected..
          define ADB_SCHEMA_NAME = '${ADB_SCHEMA_NAME}'
          define ADB_SCHEMA_PASSWORD = '${ADB_SCHEMA_PASSWORD}'
          define VERSION = '${VERSION}'
          define EDITION = '${EDITION}'
          prompt Variables defined..
          project gen-artifact -name $NAME -version $VERSION -format zip -out-dir .
          prompt Artifact generated..
          project deploy -file ${NAME}-${VERSION}.zip -log-path .
          prompt Artifact deployed..
          lb tag -tag "$VERSION"
          prompt Tagged..
          exit
          ENDSQL
          
          # Cleanup
          rm -rf "$TEMP_DB_DIR"

  deploy-web:
    needs: [fetch-bundle, deploy-db]
    if: ${{ success() && (github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')) }}
    runs-on: ubuntu-latest
    steps:
      - name: Download bundle from current workflow
        uses: actions/download-artifact@v4
        with:
          name: current-bundle
          path: bundle
      - name: Setup SSH
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          printf %s "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          printf %s "${{ secrets.SSH_HOST_KEY }}" >> ~/.ssh/known_hosts
      - name: Extract bundle
        run: |
          set -euo pipefail
          if [ ! -f "${{ needs.fetch-bundle.outputs.bundle_path }}" ]; then
            echo "::error::Bundle file not found at: ${{ needs.fetch-bundle.outputs.bundle_path }}"
            exit 1
          fi
          # Verify checksum before extraction
          SHA_FILE="bundle/$(basename "${{ needs.fetch-bundle.outputs.bundle_path }}" | sed 's/\.tar\.gz$/.sha256/')"
          if [ -f "$SHA_FILE" ]; then
            (cd bundle && sha256sum -c "$(basename "$SHA_FILE")")
          fi
          tar -xzf "${{ needs.fetch-bundle.outputs.bundle_path }}" -C bundle
          echo "Extracted bundle contents:"
          find bundle -type f -o -type d | head -20 || true
      - name: Deploy with blue/green strategy
        run: |
          set -euo pipefail
          
          for site in apps wiki main; do
            # Get current active slot
            ACTIVE=$(ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "readlink /var/www/$site/current 2>/dev/null | grep -oE '(blue|green)' || echo blue")
            INACTIVE=$([ "$ACTIVE" = "blue" ] && echo "green" || echo "blue")
            TARGET_DIR="/var/www/$site/$INACTIVE"
            
            echo "Deploying $site: $ACTIVE -> $INACTIVE"
            
            # Clean and create target directory (owned by deploy user for rsync)
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo rm -rf '$TARGET_DIR' && sudo mkdir -p '$TARGET_DIR' && sudo chown ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} '$TARGET_DIR'"
            
            # Upload content (rsync can now write)
            rsync -az -e "ssh -i ~/.ssh/deploy_key" bundle/$site/ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:"$TARGET_DIR/"
            
            # Fix permissions (change to nginx owner)
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo chown -R nginx:nginx '$TARGET_DIR' && sudo find '$TARGET_DIR' -type d -exec chmod 755 {} \; && sudo find '$TARGET_DIR' -type f -exec chmod 644 {} \;"
            
            # Flip symlink atomically
            ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo ln -sfn '$TARGET_DIR' /var/www/$site/current.tmp && sudo mv -T /var/www/$site/current.tmp /var/www/$site/current"
          done
          
          # Validate and reload nginx
          ssh -i ~/.ssh/deploy_key ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "sudo nginx -t && sudo systemctl reload nginx"
